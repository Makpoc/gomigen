// Code generated by middleware generator version "test" DO NOT EDIT.

package interfacesmw

import (
	"context"

	"github.com/Makpoc/gomigen/test/integration/testdata/tabletests/interfaces"
	"github.com/Makpoc/gomigen/types"
)

type ComposeOverlappingInterfacesMiddleware struct {
	next interfaces.ComposeOverlappingInterfaces
	hook types.Hook
}

// if this check fails middleware needs to be re-generated.
var _ interfaces.ComposeOverlappingInterfaces = (*ComposeOverlappingInterfacesMiddleware)(nil)

func NewComposeOverlappingInterfacesMiddleware(
	next interfaces.ComposeOverlappingInterfaces,
	hook types.Hook,
) *ComposeOverlappingInterfacesMiddleware {
	return &ComposeOverlappingInterfacesMiddleware{
		next: next,
		hook: hook,
	}
}

func (mw *ComposeOverlappingInterfacesMiddleware) Close() error {
	methodInfo := types.MethodInfo{
		Package:   "github.com/Makpoc/gomigen/test/integration/testdata/tabletests/interfaces",
		Interface: "ComposeOverlappingInterfaces",
		Method:    "Close",
		Params:    nil,
	}

	ctx := context.Background()

	ctx = mw.hook.OnEntry(ctx, methodInfo)
	res0 := mw.next.Close()
	mw.hook.OnExit(ctx, methodInfo, res0)
	return res0
}
func (mw *ComposeOverlappingInterfacesMiddleware) Read(arg0 /* p */ []byte) (int /* n */, error /* err */) {
	methodInfo := types.MethodInfo{
		Package:   "github.com/Makpoc/gomigen/test/integration/testdata/tabletests/interfaces",
		Interface: "ComposeOverlappingInterfaces",
		Method:    "Read",
		Params:    []interface{}{arg0},
	}

	ctx := context.Background()

	ctx = mw.hook.OnEntry(ctx, methodInfo)
	res0, res1 := mw.next.Read(arg0)
	mw.hook.OnExit(ctx, methodInfo, res1)
	return res0, res1
}
func (mw *ComposeOverlappingInterfacesMiddleware) Write(arg0 /* p */ []byte) (int /* n */, error /* err */) {
	methodInfo := types.MethodInfo{
		Package:   "github.com/Makpoc/gomigen/test/integration/testdata/tabletests/interfaces",
		Interface: "ComposeOverlappingInterfaces",
		Method:    "Write",
		Params:    []interface{}{arg0},
	}

	ctx := context.Background()

	ctx = mw.hook.OnEntry(ctx, methodInfo)
	res0, res1 := mw.next.Write(arg0)
	mw.hook.OnExit(ctx, methodInfo, res1)
	return res0, res1
}
